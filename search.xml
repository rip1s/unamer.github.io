<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[How-To-Exploit-CVE-2017-4901]]></title>
    <url>%2F2018%2F03%2F20%2FHow-To-Exploit-CVE-2017-4901%2F</url>
    <content type="text"><![CDATA[IntroductionRecently , THIS ARTICLE was published. After learning from this great post,I decide to try if I could make it. BackdoorBackdoor is a communicate mechanism between VMware host and Guest.Actually we don&#39;t need to know how it works internally. Let&#39;s see how open-vm-tools do it. Here is the code. Here is implementation in intel asm syntax. 123456789101112131415161718192021void Backdoor_InOut(Backdoor_proto *myBp) // IN/OUT&#123; _asm &#123; mov eax, myBp; push eax; mov edi, [eax + 20]; mov esi, [eax + 16]; mov edx, [eax + 12]; mov ecx, [eax + 8]; mov ebx, [eax + 4]; mov eax, [eax]; in eax, dx; xchg[esp], eax; mov[eax + 20], edi; mov[eax + 16], esi; mov[eax + 12], edx; mov[eax + 8], ecx; mov[eax + 4], ebx; pop dword ptr [eax]; &#125;;&#125; Normally this &quot;in&quot; instruction will just kill the process because we cannot execute privileged instruction in unprivileged environment. But in vmware guest,vmware is able to capture this exception and handle it. The RPCI is built on top of the aforementioned backdoor and basically allows a guest to issue requests to the host to perform certain operations.This link show how open-vm-tools do it. Since we are able to invoke RPCI as normal user in guest os ,so admin privileges aren&#39;t required. Bug in Drag and Drop RPCIThis vulnerability exists in DnD version 3. Ida shows it clearly. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051char __fastcall DnD_TransportBufAppendPacket(DnDTransportBuffer *a1, packet *a2, unsigned __int64 a3)&#123; DnDTransportBuffer *v3; // rbx@1 __int64 v4; // rcx@1 packet *v5; // rdi@1 int v6; // eax@3 int v7; // edx@3 __int64 v8; // rax@9 __int64 v9; // rcx@10 char result; // al@11 v3 = a1; v4 = a2-&gt;payloadSize; v5 = a2; if ( a3 != v4 + 20 ) goto LABEL_12; if ( a3 &gt; 0xFF9C ) goto LABEL_12; v6 = a2-&gt;offset; v7 = a2-&gt;totalSize; if ( v6 + (signed int)v4 &gt; (unsigned int)v7 || (unsigned int)v7 &gt; 0x3FFFF3 ) goto LABEL_12; if ( v3-&gt;seq != v5-&gt;seq ) sub_4F0430((__int64)v3); if ( !v3-&gt;buffer ) &#123; if ( v5-&gt;offset ) goto LABEL_12; v3-&gt;buffer = my_malloc(v5-&gt;totalSize); // alloc here v3-&gt;totalSize = v5-&gt;totalSize; v8 = v5-&gt;seq; v3-&gt;offset = 0i64; v3-&gt;seq = v8; &#125; v9 = v3-&gt;offset; if ( v9 == v5-&gt;offset ) &#123; memcpy((char *)v3-&gt;buffer + v9, v5-&gt;payload, v5-&gt;payloadSize);// bug here result = 1; v3-&gt;offset += v5-&gt;payloadSize; return result; &#125;LABEL_12: free(v3-&gt;buffer); v3-&gt;buffer = 0i64; v3-&gt;seq = 0i64; v3-&gt;totalSize = 0i64; v3-&gt;offset = 0i64; v3-&gt;lastUpdateTime = 0i64; return 0;&#125; Code above indicates nothing checks on totalsize property, so what will happen if we enlarge the totalsize in second packet? ReversingIt is needed to mention that my vmware-vmx.exe version is 12.5.2.13578, workstation&#39;s is 12.5.2-build4638234. From xref results of string &quot;tools.capability.dnd_version&quot;,we could find corresponding handle function of this RPCI command easily. 12345678910bindfun(31, "printerSetDisable", "tools.capability.printer_set", sub_83BA0, 0i64);bindfun(34, "ptrGrabDisable", "vmx.capability.ptr_grab_notification", sub_88130, (__int64)&amp;qword_B87338);bindfun(37, "hgfsServerSetDisable", "tools.capability.hgfs_server", sub_83DF0, 0i64);bindfun(32, "openUrlDisable", "tools.capability.open_url", sub_83C60, 0i64);bindfun(33, "autoUpgradeDisable", "tools.capability.auto_upgrade", sub_83D20, 0i64);bindfun(52, "guestTempDirectoryDisable", "tools.capability.guest_temp_directory", sub_854A0, 0i64);bindfun(66, "guestConfDirectoryDisable", "tools.capability.guest_conf_directory", sub_85F10, 0i64);bindfun(41, "guestDnDVersionSetDisable", "tools.capability.dnd_version", dndversionset, 0i64);bindfun(42, "vmxDnDVersionGetDisable", "vmx.capability.dnd_version", vmxDndVer, 0i64);bindfun(43, "guestCopyPasteVersionSetDisable", "tools.capability.copypaste_version", sub_83F80, 0i64); The fourth parameter of bindfun is the corresponding handler of the RPCI command in third parameter. All the RPCI handler defines in same way:1char __usercall handler(__int64 a1, __int64 a2, __int64 requ, __int64 requestlen, char **reply, __int64 *replylen) First parameter is the fifth parameter in bindfun. Second parameter is unknow for now :). Third parameter is original RPCI request guest system sent. Fourth parameter is the length of original RPCI request. Fifth parameter is the reply addr. Sixth parameter is the length of reply. Handler of RPCI command &quot;vmx.capability.dnd_version&quot; checks if current dnd version corresponds the version in data segment (set by RPCI &quot;tools.capability.dnd_version&quot;). New object will be created if version mismatched. 12345678910111213141516171819202122232425char __fastcall vmxDndVer(__int64 a1, __int64 a2, __int64 a3, int a4, const char **a5, _DWORD *a6)&#123; char result; // al@2 __int64 v7; // r9@4 signed int ver; // [sp+48h] [bp+20h]@3 if ( a4 ) &#123; result = setreply(a5, a6, "No argument expected", 0); &#125; else &#123; if ( (signed int)sub_410700((__int64)vmdbmain, (__int64)"vmx/dnd/cap/dndGuestVersion", &amp;ver) &lt; 0 || (v7 = (unsigned int)ver, ver &lt; 2) || (signed int)v7 &gt; 4 ) &#123; v7 = 4i64; ver = 4; &#125; my_sprintf_0(currentDndVer, 4i64, (__int64)"%d", v7); UpdateDndCpVer(ver); // update and create new object result = setreply(a5, a6, currentDndVer, 1); &#125; return result;&#125; The size of dnd object(version 3) is 0xa8, so as cp object.1234567891011121314151617int __fastcall initialCPObject(__int64 a1, int ver)&#123;........ if ( v6 == 1 ) // version 3 &#123; v8 = j_my_malloc(0xA8ui64); if ( v8 ) &#123; v11 = initCP((__int64)v8, v2, 4);LABEL_12: v4 = v11; goto LABEL_13; &#125; goto LABEL_13; &#125;..........&#125; ExploitationAmat suggests to use RPCI command pair &quot;info-set&quot; and &quot;info-get&quot; to leak data from heap.The inner structure of &quot;info-set&quot; command handler is quite complicated. After debugging in windbg, I realize that we can create a buffer with 0xa8 size by &quot;info-set guestinfo.test1 &quot;+&quot;a&quot;*0xa7. During the &quot;info-set&quot; function, buffer allocation with size 0xa8 appears multiply times (more than 10),almost all buffers are freed except one. That indicates the &quot;info-set&quot; command will strongly interfere the heap layout. I&#39;m not good at defeating LFH in windows, so I cannot guarantee the successfully rate of exploitation.In fact, I didn&#39;t solve it nicely in the heap &quot;fengshui&quot;.Most time is pray-after-free. Here is the heap layout we want:12345----------- ----------- -----------| |overflow | info-set|overflow | DnD/CP || Vuln |---------&gt;| value |---------&gt;| Object || buffer | | buffer | | buffer |----------- ----------- ----------- If you fail to build this layout, exploit will crash the vmware-vmx.exe in most situation. If you fail to build this layout and you are currently debugging with windbg, congratulations, the whole host system will stuck but you are able to move your cursor very very slowly to windbg command window and press F5.(unknow bug) I had written a simple script to print the object address , saved as dumprax.py.123456from pykd import *import syss=''if len(sys.argv)&gt;1: s=sys.argv[1]+' 'print s+'Object at '+hex(reg('rax')) With this script you are able to use the command below to set series breakpoints quickly.1bp 7FF7E394C4D8 &quot;!py dumprax DnD;gc;&quot;;bp 7FF7E394BF68 &quot;!py dumprax CP;gc;&quot;;bp 7FF7E3DA05AB &quot;!py dumprax vuln;gc;&quot;;bp 7FF7E3DA05DB;bp 7ff7e38c1b2d;bp 7ff7`e38f1dc2;g First breakpoint is the next instruction after the dnd object allocation. Second is the next instruction after the cp object allocation. Third is the next instruction after the vuln buffer allocation. Fourth is where the vulnerability is. Fifth and Sixth are gadgets. Tips: Program changes the base address only if you restart your computer. &quot;info-get&quot; command will let us know whether we overwrite the contents in &quot;info-set value buffer&quot; successfully.After that ,we are able to leak the vtable pointer in object. DnD object overwrittenThe upper level function of DnD_TransportBufAppendPacket will call vtable instantly after overwritten, so we need to ensure all things right before the overwritten.1234567891011121314151617.text:00000000004FEA06 test rax, rax.text:00000000004FEA09 jz short loc_4FE9E3.text:00000000004FEA0B mov rcx, [rbx+8].text:00000000004FEA0F mov r8, [rsp+28h+Memory].text:00000000004FEA14 mov r9, rax.text:00000000004FEA17 mov r10, [rcx].text:00000000004FEA1A xor edx, edx.text:00000000004FEA1C call qword ptr [r10+10h] ; vtable call.text:00000000004FEA20 test al, al.text:00000000004FEA22 jnz short loc_4FEA2D.text:00000000004FEA24 lea rcx, [rbx+40h].text:00000000004FEA28 call sub_4F0430.text:00000000004FEA2D.text:00000000004FEA2D loc_4FEA2D: ; CODE XREF: sub_4FE960+C2j.text:00000000004FEA2D mov rcx, [rsp+28h+Memory] ; Memory.text:00000000004FEA32 call cs:__imp_free.text:00000000004FEA38 mov rdi, [rsp+28h+arg_0] The RPCI command &quot;unity.window.contents.start&quot; will create a buffer with specified size in heap, and &quot;unity.window.contents.chunk&quot; is able to store some data into this buffer.1NOTE: The parameter of this two unity command need to serialized correctly. Surprisingly,the data segment of vmware-vmx.exe has rwx attribute! Just copy shellcode to data segment and jump to it! CP Object overwrittenVMware will invoke destructor while freeing CP object, that&#39;s how we gain the rip control. We can write a QWORD through RPCI command &quot;unity.window.contents.start&quot; to data segment.We know the global variable address because we have leaked the base address. Setting back the CP version will call the destructor of CP object, and we win! Final words &quot;Talk is cheap, show me the code&quot;. Here is exploit code you need. All stuffs included.]]></content>
      <categories>
        <category>Pwn</category>
        <category>VMware</category>
      </categories>
  </entry>
</search>
